import { addDoc, arrayRemove, arrayUnion, collection, CollectionReference, deleteDoc, doc, DocumentReference, getDoc, getDocs, query, Query, QueryConstraint, setDoc, updateDoc } from "firebase/firestore";
import { db } from "../App";
import { FirebaseData } from "./FirebaseData";
import { LocalData } from "./LocalData";

interface NoParamConstructor<T extends FirebaseData> {
  new (id: string, collection: string, parent: FirebaseData | undefined): T;
}

export default class CollectionLoader<T extends FirebaseData> {
  collection: string = "";
  path: string = "";
  parent?: FirebaseData;
  loaded = false;
  loading = false;
  documents: T[] = [];
  private docType: NoParamConstructor<T>;

  constructor(collection: string, parent: FirebaseData | undefined, docType: NoParamConstructor<T>) {
    this.collection = collection;
    this.parent = parent;
    this.path = (parent ? parent.collectionName + "/" + parent.id + "/" : "") + collection;
    this.docType = docType;
  }

  loadDocuments(): Promise<this> {
    return new Promise<this>(async (resolve, reject) => {
      getDocs(collection(db, this.path))
        .then((docSnap) => {
          docSnap.forEach(async (doc) => {
            let dataDoc = this.addData(doc.id);
            dataDoc.setup(doc.data());
          });
          resolve(this);
        })
        .catch((error) => {
          reject(error);
        });
    });
  }

  /* async loadById(id: string) {
    return new Promise<this>(async (resolve, reject) => {
      const docRef = doc(db, "ads", id);
      const docSnap = await getDoc(docRef);
      let dataDoc = this.addData(docSnap.id)
      dataDoc.setup(docSnap.data());
      if (docSnap.id !== id) {
        reject(dataDoc)
      }
      resolve(this);
    });
  } */

  loadDocumentsWithFilter(constraint?: QueryConstraint[]): Promise<T[]> {
    return new Promise<T[]>(async (resolve, reject) => {
      let docs = collection(db, this.path);
      getDocs(constraint ? query(docs, ...constraint) : docs)
        .then((docSnap) => {
          let docDatas: T[] = [];
          docSnap.forEach(async (doc) => {
            let dataDoc = this.addData(doc.id);
            dataDoc.setup(doc.data());
            docDatas.push(dataDoc);
          });
          resolve(docDatas);
        })
        .catch((error) => {
          reject(error);
        });
    });
  }

  // Returns a document with the given id. If the document does not exist, it will be created.
  addData(id: string): T {
    const existing = this.documents.find((doc) => doc.id === id);
    if (existing) {
      return existing;
    }

    const document = new this.docType(id, this.collection, this.parent);
    document.parent = this.parent;
    this.documents.push(document);
    return document;
  }

  /**
   * Creates a new document.
   *
   * @param value: the object to be stored in the document
   * @param id: the id of the document
   * @returns undefined
   */
  createNewDocument(id: string, value: object) {
    return new Promise<undefined>((resolve, reject) => {
      setDoc(doc(db, this.path, id), value)
        .then(() => {
          resolve(undefined);
        })
        .catch((error) => {
          reject(error);
        });
    });
  }

  /**
   * Creates a new document without an id. The id will be generated by firestore.
   *
   * @param value: the object to be stored in the document
   * @returns A reference to the newly created document
   */
  createNewDocumentWithoutId(value: object) {
    return new Promise<DocumentReference>((resolve, reject) => {
      addDoc(collection(db, this.path), value)
        .then((docRef) => {
          resolve(docRef);
        })
        .catch((error) => {
          reject(error);
        });
    });
  }

  deleteDocument(data: T): Promise<void> {
    return new Promise<void>(async (resolve, reject) => {
      const docRef = doc(db, this.path, data.id);
      deleteDoc(docRef)
        .then(async (doc) => {
          const index = this.documents.indexOf(data);
          if (index > -1) {
            this.documents.splice(index, 1);
          }
          resolve();
        })
        .catch((error) => {
          reject(error);
        });
    });
  }

  async getFavs(adId: any, userId: String) {
    let id = userId as string;
    const user = await (await getDoc(doc(db, "users", id))).data();
    const fav = user?.favorites;
    if(fav.includes(adId as string)) {
      return true
    } 
    else {
      return false
    }
  }

  async addNewFavorite(newFavorite: any, userId: String) {
    let id = userId as string;
    const user = await (await getDoc(doc(db, "users", id))).data();
    const fav = user?.favorites;
    if (fav.includes(newFavorite as string)){
      await updateDoc(doc(db, "users", id), {
        favorites: arrayRemove(newFavorite),
      });
      return false;
    } else {
      await updateDoc(doc(db, "users", id), {
        favorites: arrayUnion(newFavorite),
      });
      return true;
    }
  }
}
